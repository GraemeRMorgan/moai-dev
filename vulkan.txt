
SHADERS/MATERIALS specify LAYOUTS (descriptor and pipeline)
    this makes sense, since shaders ultimately consume bound resources

LAYOUTS determine pipeline creation
    this makes sense, since pipelines are specified based on layouts
    pipelines don't need to be re-created based on bindings

MOAI GFX STATE MGR can specify global address slots for resources

when MOAI GFX STATE MGR resources change, a new DESCRIPTOR SET is required
    state manager grabs new DESCRIPTOR SETs on the fly
    DESCRIPTOR SETs don't specify global source addresses

UNIFORM BUFFERs need to be cached and bound with command buffers
    reallocate if changed

possible to cache DESCRIPTOR SETS (and bindings) across multiple frames
    i.e. don't reuse DESCRIPTOR SETS if their bindings haven't changed
    so for a couple of frames, there will be as many DESCRIPTOR SETS as there
        are combinations of bindings

any operations not recorded in a command buffer need a copy of the object in question
    such as DESCRIPTOR SETS

per thread POOLS?

DESCRIPTOR SET LAYOUT
    specifies resource type per index
    easy to hash

PIPELINE LAYOUT
    specified descriptor set layour per index

vk buffers - uniform, texture, vertex, etc.
    factory and instance - auto buffer
        copy only contents to instance
        single copy held in factory
        factory snapshots new copies only if instance changes (since last draw)
        flag if possible change (may not guarantee change)
        many instances may share same factory
    manual
        one factory to one instance
        factory may be configured without cache - manual update required
        must always snapshot if dirty possible

SnapshotSignature - unique identifier of subject; raw memory or resource descriptor
SnapshotSubject - contains buffer; a thing that is snapshotted
SnapshotCache - caches snapshots for command list
Snapshot - vk resource cached in command list

--> don't like snapshots any more
vk drawables have lifecycle info
may be shared by multiple command buffers
holders can inspect lifecycle and tag to determine reuse

Dependency DAG implementation (needed yet?)
DependencyProvider
DependencyClient - GetProvider< TYPE>();
Dependency - force cleanup

Select Textures
    OpenGL -> bind material mgr textures to (global) texture units
    Vulkan -> bind material mgr textures to (local, ad hoc) descriptor sets

Trigger Redraw
    Pipeline change (shader, prim, vtx format, etc.)
    DescriptorSet change (uniforms, textures, etc.)

Uniform (Texture) Composer
    Needs client type (OpenGL vs Vulkan)
    Destinations are different - GfxMgr GL texture units vs VK DescriptorSet

OR... Vulkan virtual texture units?

Vulkan GPU cache totally different?
    GL style cache as broad phase?

UniformComposer uses global state from GfxMgr (pipeline globals and texture units)
UniformComposer should have nothing to do with MaterialMgr
MaterialMgr texture names should map 1:1 OpenGL texture units
DescriptorSet can pull textures from virtual texture units

2019-12-09:
    left off with a minimal implementation using Moai pipeline geometry and data.
    next steps will be to set up pools for re-use pipelines and other command buffer resources (aka "snapshots").
    also: get the render pass and subpass architecture in place. should work with a "default pass," but need to
    support user-defined passes with complex bindings.

    may make sense to share the render pass and subpass model across api implementations (VK and GL). is a moai
    "layer" basically a subpass? as we get into multi-pass, should we cache scene query results during drawing?

    think about moving away from thread-local statics, or at least provide an opt-out.

2020-03-12
    need text script for multi-pass
    need to verify draw caching (expose draw prim per-frame metrics)

------

pipeline
descriptor set

pipeline layout                 - MOAIPipelineInputBodySchemaVK
descriptor set layout           - MOAIPipelineInputChunkSchemaVK - describes what kind of buffers get bound

composer                        - MOAIPipelineInputBodyVK
descriptor set                  - MOAIPipelineInputChunkVK

MOAIPipelineInputBodyComposer

SET UP RENDER STATE
    named textures
    uniforms
    rendering options
    shaders
GATHER STATE AND UPDATE BUFFERS
    -> composition (before gfx state cache evaluation)
    -> composition (after gfx state cache evaluation?)
    -> evaluate and apply (double buffer; graphics cahe)
    -> evaluate and apply (single objects?)
CHECK FOR CHANGE AND FLUSH
DRAW PRIMS or BUFFER GEOMETRY

------

draw - some items set ad hoc during sim and drawing ("globals")

DrawPrims
compose - set local and global (CPU) state - ad hoc, per-implementation
diff - check to see if gfx state (CPU) has changed
apply - flush prims and move gfx state to GPU

composition
- textures
- uniforms

should shaders be composed? or are shaders composers? seems like the latter. OK to decouple shaders, uniform buffers and composers?

buffer - texture, uniform, vertex, index - have changed? create snapshot?
in GL these are: uniforms are buffered by shader program; textures are global texture units
in VK these are: configurations of buffers shared by multiple shaders 
